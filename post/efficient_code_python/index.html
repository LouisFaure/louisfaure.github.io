<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=generator content="Source Themes Academic 4.5.0"><link rel=stylesheet href=https://louis.faure.dev/css/shield.css><meta name=author content="Louis Faure"><meta name=description content="Speeding up code is sometimes an overlooked aspect in the field computational biology. Numerous constraints (multiple projects, grant proposals, pressure to publish, etc.) often lead many to write simple implementations of a given function, at the expense of efficiency. This is problematic as such code is likely not scallable, which can limit further discoveries done by other reseachers. In this article, I will look at all tasks performed by a specific python function I have designed, showing first an example of slow code, and then a suggestion of a faster implementation."><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["$","$"]]}}</script><link rel=alternate hreflang=en-us href=https://louis.faure.dev/post/efficient_code_python/><meta name=theme-color content="#0A1922"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/atom-one-dark.min.css crossorigin=anonymous title=hl-light><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/atom-one-dark.min.css crossorigin=anonymous title=hl-dark disabled><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css integrity="sha256-SHMGCYmST46SoyGgo4YR/9AlK1vf3ff84Aq9yK4hdqM=" crossorigin=anonymous><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather%7CRoboto+Mono%7CRoboto&display=swap"><link rel=stylesheet href=/css/academic.css><script async src="https://www.googletagmanager.com/gtag/js?id=UA-175353387-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}function trackOutboundLink(e){gtag("event","click",{event_category:"outbound",event_label:e,transport_type:"beacon",event_callback:function(){document.location=e}}),console.debug("Outbound link clicked: "+e)}function onClickCallback(e){if(e.target.tagName!=="A"||e.target.host===window.location.host)return;trackOutboundLink(e.target)}gtag("js",new Date),gtag("config","UA-175353387-1",{}),document.addEventListener("click",onClickCallback,!1)</script><link rel=manifest href=/index.webmanifest><link rel=icon type=image/png href=/img/icon-32.png><link rel=apple-touch-icon type=image/png href=/img/icon-192.png><link rel=canonical href=https://louis.faure.dev/post/efficient_code_python/><meta property="twitter:card" content="summary"><meta property="og:site_name" content="Louis Faure"><meta property="og:url" content="https://louis.faure.dev/post/efficient_code_python/"><meta property="og:title" content="Scalable & Sustainable Computational Biology: Vectorization, Indexing Tricks, and Numba/Cython | Louis Faure"><meta property="og:description" content="Speeding up code is sometimes an overlooked aspect in the field computational biology. Numerous constraints (multiple projects, grant proposals, pressure to publish, etc.) often lead many to write simple implementations of a given function, at the expense of efficiency. This is problematic as such code is likely not scallable, which can limit further discoveries done by other reseachers. In this article, I will look at all tasks performed by a specific python function I have designed, showing first an example of slow code, and then a suggestion of a faster implementation."><meta property="og:image" content="https://louis.faure.dev/img/headers/newyork.jpg"><meta property="twitter:image" content="https://louis.faure.dev/img/headers/newyork.jpg"><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2024-03-28T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-28T00:00:00+00:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://louis.faure.dev/post/efficient_code_python/"},"headline":"Scalable \u0026 Sustainable Computational Biology: Vectorization, Indexing Tricks, and Numba/Cython","datePublished":"2024-03-28T00:00:00Z","dateModified":"2024-03-28T00:00:00Z","author":{"@type":"Person","name":"Louis Faure"},"publisher":{"@type":"Organization","name":"Louis Faure","logo":{"@type":"ImageObject","url":"https://louis.faure.dev/img/icon-512.png"}},"description":"Speeding up code is sometimes an overlooked aspect in the field computational biology. Numerous constraints (multiple projects, grant proposals, pressure to publish, etc.) often lead many to write simple implementations of a given function, at the expense of efficiency. This is problematic as such code is likely not scallable, which can limit further discoveries done by other reseachers. In this article, I will look at all tasks performed by a specific python function I have designed, showing first an example of slow code, and then a suggestion of a faster implementation."}</script><title>Scalable & Sustainable Computational Biology: Vectorization, Indexing Tricks, and Numba/Cython | Louis Faure</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents><style>.wallpaper{position:fixed;bottom:0;right:0;height:100vh;width:auto;object-fit:cover;z-index:-9999}</style><div class=wallpaper><img src=https://louis.faure.dev//img/headers/newyork.jpg style=width:100%;height:auto;min-height:100%;min-width:1024px></div><aside class=search-results id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class=col-6><h1>Search</h1></div><div class="col-6 col-search-close"><a class=js-search href=#><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box><input name=q id=search-query placeholder=Search... autocapitalize=off autocomplete=off autocorrect=off spellcheck=false type=search></div></section><section class=section-search-results><div id=search-hits></div></section></div></aside><nav class="navbar navbar-light fixed-top navbar-expand-lg py-0 compensate-for-scrollbar" id=navbar-main><div class=container><a class=navbar-brand href=/>Louis Faure</a>
<button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar aria-controls=navbar aria-expanded=false aria-label="Toggle navigation">
<span><i class="fas fa-bars"></i></span></button><div class="collapse navbar-collapse" id=navbar><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=/#about><span>About</span></a></li><li class=nav-item><a class=nav-link href=/#skills><span>Skills</span></a></li><li class=nav-item><a class=nav-link href=/#talk><span>Talks/Poster</span></a></li><li class=nav-item><a class="nav-link active" href=/post/><span>Blog posts</span></a></li><li class=nav-item><a class=nav-link href=/#featured><span>Publications</span></a></li><li class=nav-item><a class=nav-link href=/#experience><span>Experience</span></a></li><li class=nav-item><a class=nav-link href=/files/CV.pdf><span>CV</span></a></li></ul><ul class="navbar-nav ml-auto"><li class=nav-item><a class="nav-link js-search" href=#><i class="fas fa-search" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link js-dark-toggle" href=#><i class="fas fa-moon" aria-hidden=true></i></a></li></ul></div></div></nav><div class=article-cont><article class=article><div class=article-container><h1>Scalable & Sustainable Computational Biology: Vectorization, Indexing Tricks, and Numba/Cython</h1><div class=article-metadata><span class=article-date>Mar 28, 2024
</span><span class=middot-divider></span>
<span class=article-reading-time>9 min read</span></div></div><div class=article-container><div class=article-style><p><a href="https://github.com/LouisFaure/Blog_notebooks/blob/main/efficient_code_python
/Efficient_code_python.ipynb"><img alt="Jupyter Notebook" src="https://img.shields.io/badge/jupyter-%23FA0F00.svg?style=for-the-badge&amp;logo=jupyter&amp;logoColor=white" style="margin-left:0;margin-top:0;margin-bottom:0;border-radius:5px;box-shadow:0 4px 16px rgba(0,0,0,.1)"></a></p><p>Speeding up code is sometimes an overlooked aspect in the field computational biology. Numerous constraints (multiple projects, grant proposals, pressure to publish, etc.) often lead many to write simple implementations of a given function, at the expense of efficiency. This is problematic as such code is likely not scallable, which can limit further discoveries done by other reseachers. In this article, I will look at all tasks performed by a specific python function I have designed, showing first an example of slow code, and then a suggestion of a faster implementation. I hope this will provide some tips to you to perform a scalable, more efficient and <a href=https://www.green-algorithms.org>environmentally friendly</a> science!</p><h2 id=the-task>The Task</h2><p>During my research, I was assigned to implement a relatively simple function. We work with single-cell data that includes clonal barcodes. These barcodes allow us to group and identify cells that belong to the same lineage, as a barcode would be passed from the mother cell to all subsequent daughter cells. Clonal barcoding is a potent tool for studying early fate biasing and can be used as input for some tools to infer the fate of non-barcoded neighboring cells.</p><p>The most basic fate bias estimation between two fates in barcoded cells consists in counting occurences of the fates in each clones. We then compare these occurences to the occurences of other fates in order to statistically assign a fate bias.</p><p>More precisely, we will calculate fate bias $f$ as following:</p>$$
f = \frac{c_A}{c_A+{c_B}\times{\alpha}^{-1}}
$$<p>with $c_A$ and $c_B$ being the number of occurence of our fates A and B in each clone, and $\alpha= \frac{\sum c_A}{\sum c_B}$ is the ratio of the sum of all observed clones for each fate.</p><p>To test of significance of fate bias, we will perform a Fisher extact test, with a 2x2 contigency table:</p>$$
\begin{align*}
\begin{array}{|c|c|}
\hline
c_A & c_B \\
\hline
\sum c_A & \sum c_B \\
\hline
\end{array}
\end{align*}
$$<p>While this task should not be compute intensive, there are several good examples of slow and inefficient code that could be fixed. You will see that slowness is not only caused by slow calculation, but also data access!</p><h3 id=the-system-used-for-benchmark>The system used for benchmark</h3><p>The numbers showed here comes from tests with my MacBook Pro M2P 32GB.</p><p>I used python 3.10.13 and installed the following packages:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pip install cospar fast_fisher
</span></span></code></pre></div><h2 id=loading-libraries-and-the-data>Loading libraries and the data</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> cospar <span style=color:#66d9ef>as</span> cs
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> warnings
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> scanpy <span style=color:#66d9ef>as</span> sc
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span>sc<span style=color:#f92672>.</span>set_figure_params()
</span></span><span style=display:flex><span>warnings<span style=color:#f92672>.</span>filterwarnings(<span style=color:#e6db74>&#39;ignore&#39;</span>)
</span></span></code></pre></div><h3 id=quick-overview-of-the-data>Quick overview of the data</h3><p>The data we will use here is a 30k+ cells <a href=https://www.science.org/doi/10.1126/science.aaw3381>dataset of mouse hematopoiesis</a>. The cells were clonally barcoded once and then were subsequently sampled at multiple time points.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>adata_orig <span style=color:#f92672>=</span> cs<span style=color:#f92672>.</span>datasets<span style=color:#f92672>.</span>hematopoiesis()
</span></span></code></pre></div><p>We will focus on the bifurcation between Monocytes and Neutrophils:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>mask <span style=color:#f92672>=</span> adata_orig<span style=color:#f92672>.</span>obs<span style=color:#f92672>.</span>state_info<span style=color:#f92672>.</span>isin([<span style=color:#e6db74>&#34;Monocyte&#34;</span>,<span style=color:#e6db74>&#34;Neutrophil&#34;</span>]) <span style=color:#f92672>|</span> adata_orig<span style=color:#f92672>.</span>obs<span style=color:#f92672>.</span>NeuMon_mask
</span></span><span style=display:flex><span>adata <span style=color:#f92672>=</span> adata_orig[mask]<span style=color:#f92672>.</span>copy()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>sc<span style=color:#f92672>.</span>pl<span style=color:#f92672>.</span>embedding(adata,color<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;state_info&#34;</span>,basis<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;emb&#34;</span>)
</span></span></code></pre></div><p><img alt=png src=/post/efficient_code_python/output_10_0.png></p><h3 id=some-parameters-needed>Some parameters needed</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>clone <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;X_clone&#39;</span> <span style=color:#75715e># key to access the clonal matrix</span>
</span></span><span style=display:flex><span>fA <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Neutrophil&#39;</span> <span style=color:#75715e># fate A</span>
</span></span><span style=display:flex><span>fB <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Monocyte&#39;</span>   <span style=color:#75715e># fate B</span>
</span></span><span style=display:flex><span>state_key <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;state_info&#39;</span> <span style=color:#75715e># key for fate assignments</span>
</span></span><span style=display:flex><span>cutoff <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.01</span> <span style=color:#75715e># cutoff for Fisher test corrected p-values</span>
</span></span></code></pre></div><h2 id=getting-cell-indices-for-each-clone>Getting cell indices for each clone</h2><p>We use a clone matrix saved in anndata under <code>obsm</code> as a sparse matrix, where the rows are cells and columns are clones. We need to extract which cell belong to which clone. In other words, the task is to retrieve row indices of each column.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_cellid_per_clone</span>(adata,clone):
</span></span><span style=display:flex><span>    X_clone <span style=color:#f92672>=</span> adata<span style=color:#f92672>.</span>obsm[clone]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [np<span style=color:#f92672>.</span>argwhere(X_clone[:,i])[:,<span style=color:#ae81ff>0</span>] <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(X_clone<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>1</span>])]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>start <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>cid <span style=color:#f92672>=</span> get_cellid_per_clone(adata,clone)
</span></span><span style=display:flex><span>end <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>(end<span style=color:#f92672>-</span>start)<span style=color:#e6db74>:</span><span style=color:#e6db74>.3</span><span style=color:#e6db74>}</span><span style=color:#e6db74>s&#39;</span>)
</span></span></code></pre></div><pre><code>0.774s
</code></pre><p>Why is this method slow? Though this approach is simple and straightforward (practically one line), a <code>for</code> loop that calls <code>np.argwhere</code> for each of the columns implies that we are not leveraging numpy&rsquo;s ability to perform operations on entire arrays at once.</p><p>Let&rsquo;s have a look at a faster implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_cellid_per_clone_f</span>(adata,clone):
</span></span><span style=display:flex><span>    X_clone <span style=color:#f92672>=</span> adata<span style=color:#f92672>.</span>obsm[clone]
</span></span><span style=display:flex><span>    <span style=color:#75715e># Extract and sort row and columns</span>
</span></span><span style=display:flex><span>    rows, cols <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>nonzero(X_clone)
</span></span><span style=display:flex><span>    sort_idx <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>argsort(cols)
</span></span><span style=display:flex><span>    rows_sorted <span style=color:#f92672>=</span> rows[sort_idx]
</span></span><span style=display:flex><span>    cols_sorted <span style=color:#f92672>=</span> cols[sort_idx]
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get the count of unique columns</span>
</span></span><span style=display:flex><span>    _, counts <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>unique(cols_sorted, return_counts<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Split rows_sorted based on counts</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> np<span style=color:#f92672>.</span>split(rows_sorted, np<span style=color:#f92672>.</span>cumsum(counts[:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]))
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>start <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>cid <span style=color:#f92672>=</span> get_cellid_per_clone_f(adata,clone)
</span></span><span style=display:flex><span>end <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>(end<span style=color:#f92672>-</span>start)<span style=color:#e6db74>:</span><span style=color:#e6db74>.3</span><span style=color:#e6db74>}</span><span style=color:#e6db74>s&#39;</span>)
</span></span></code></pre></div><pre><code>0.00531s
</code></pre><p>Why is this fast? Because we use numpy&rsquo;s vectorized function <code>np.nonzero</code> to find the indices of non-zero elements in the entire array at once. Then, we sort these indices based on the column indices and splits them into separate arrays for each column. By sorting the indices based on the column indices (<code>np.argsort</code> is also vectorized), the function avoids having to access the columns individually.</p><h2 id=getting-occurence-of-our-two-fate-labels-in-each-clone>Getting occurence of our two fate labels in each clone</h2><p>We want to count the occurence of our two fate labels in each clone and the total of each fate. This involves to retrieve the cluster assignment for each cell within each clone.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_counts_per_clone</span>(adata,cid,state_key):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Convert cell id to assigned cell state for each clone</span>
</span></span><span style=display:flex><span>    cl <span style=color:#f92672>=</span> [adata[c]<span style=color:#f92672>.</span>obs[state_key] <span style=color:#66d9ef>for</span> c <span style=color:#f92672>in</span> cid]
</span></span><span style=display:flex><span>    <span style=color:#75715e># Count occurences of states per clone</span>
</span></span><span style=display:flex><span>    clA <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([(c<span style=color:#f92672>==</span>fA)<span style=color:#f92672>.</span>sum() <span style=color:#66d9ef>for</span> c <span style=color:#f92672>in</span> cl])
</span></span><span style=display:flex><span>    clB <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([(c<span style=color:#f92672>==</span>fB)<span style=color:#f92672>.</span>sum() <span style=color:#66d9ef>for</span> c <span style=color:#f92672>in</span> cl])
</span></span><span style=display:flex><span>    clAsum, clBsum <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>sum(clA) , np<span style=color:#f92672>.</span>sum(clB)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> clA, clB, clAsum, clBsum
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>start <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>clA, clB, clAsum, clBsum <span style=color:#f92672>=</span> get_counts_per_clone(adata,cid,state_key)
</span></span><span style=display:flex><span>end <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>(end<span style=color:#f92672>-</span>start)<span style=color:#e6db74>:</span><span style=color:#e6db74>.3</span><span style=color:#e6db74>}</span><span style=color:#e6db74>s&#39;</span>)
</span></span></code></pre></div><pre><code>1.84s
</code></pre><p>Why is this slow? Here the issue lies on the repeated access of the anndata object in a <code>for</code> loop, which is not very efficient. Also, although this does not have that much of an impact, the function calculates the sum of clA and clB separately.</p><p>Here is a faster implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_counts_per_clone_f</span>(adata,cid,state_key):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get cell id and clone id array</span>
</span></span><span style=display:flex><span>    i <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>repeat(np<span style=color:#f92672>.</span>arange(len(cid)), [len(c) <span style=color:#66d9ef>for</span> c <span style=color:#f92672>in</span> cid])
</span></span><span style=display:flex><span>    c <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>concatenate(cid)
</span></span><span style=display:flex><span>    cid_cl <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>column_stack((c, i))
</span></span><span style=display:flex><span>    <span style=color:#75715e># apply cell/clone id array to states array</span>
</span></span><span style=display:flex><span>    df <span style=color:#f92672>=</span> adata<span style=color:#f92672>.</span>obs[[state_key]]
</span></span><span style=display:flex><span>    df[<span style=color:#e6db74>&#34;clone&#34;</span>]<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>nan
</span></span><span style=display:flex><span>    df<span style=color:#f92672>.</span>iloc[cid_cl[:,<span style=color:#ae81ff>0</span>],<span style=color:#ae81ff>1</span>]<span style=color:#f92672>=</span>cid_cl[:,<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    <span style=color:#75715e># Count occurences of states per clone</span>
</span></span><span style=display:flex><span>    cnts <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>groupby(state_key)<span style=color:#f92672>.</span>value_counts([<span style=color:#e6db74>&#34;clone&#34;</span>])
</span></span><span style=display:flex><span>    clAB <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>concat([cnts[fA]<span style=color:#f92672>.</span>sort_index(),cnts[fB]<span style=color:#f92672>.</span>sort_index()],axis<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>.</span>values
</span></span><span style=display:flex><span>    clA, clB <span style=color:#f92672>=</span> clAB[:,<span style=color:#ae81ff>0</span>], clAB[:,<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    clAsum, clBsum <span style=color:#f92672>=</span> clAB<span style=color:#f92672>.</span>sum(axis<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> clA, clB, clAsum, clBsum
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>start <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>clA, clB, clAsum, clBsum <span style=color:#f92672>=</span> get_counts_per_clone_f(adata,cid,state_key)
</span></span><span style=display:flex><span>end <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>(end<span style=color:#f92672>-</span>start)<span style=color:#e6db74>:</span><span style=color:#e6db74>.3</span><span style=color:#e6db74>}</span><span style=color:#e6db74>s&#39;</span>)
</span></span></code></pre></div><pre><code>0.0107s
</code></pre><p>Why is this fast? First, we used vectorized functions <code>np.column_stack</code> and <code>np.repeat</code> to create a numpy array assigning each cell index to a clone id. Then, we use the <code>groupby</code> method from pandas, which is optimized for grouping and aggregating data. Finally, the anndata is read and writen only once, avoiding the usage of any <code>for</code> loop.</p><h2 id=calculating-fate-bias-and-its-significance-per-cell>Calculating fate bias and its significance per cell</h2><p>We will use the equation mentionned in the introduction, as well as Fisher exact test. More precisley, we will perform the test on each clone using extracted counts of our two fates and their total sum.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_fate_bias</span>(clA,clB,clAsum, clBsum):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Perform Fisher extact test on clone counts</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>from</span> scipy.stats <span style=color:#f92672>import</span> fisher_exact
</span></span><span style=display:flex><span>    pvals <span style=color:#f92672>=</span> [fisher_exact(np<span style=color:#f92672>.</span>array([[cla,clb], [clAsum, clBsum]]))[<span style=color:#ae81ff>1</span>] 
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>for</span> cla,clb <span style=color:#f92672>in</span> zip(clA,clB)]
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get fate biasing using clone counts</span>
</span></span><span style=display:flex><span>    slope <span style=color:#f92672>=</span> clAsum<span style=color:#f92672>/</span>clBsum
</span></span><span style=display:flex><span>    fate_bias <span style=color:#f92672>=</span> clA<span style=color:#f92672>/</span> (clA <span style=color:#f92672>+</span> clB<span style=color:#f92672>/</span>slope)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pvals, slope, fate_bias
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>start <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>pvals, slope, fate_bias <span style=color:#f92672>=</span> get_fate_bias(clA,clB,clAsum, clBsum)
</span></span><span style=display:flex><span>end <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>(end<span style=color:#f92672>-</span>start)<span style=color:#e6db74>:</span><span style=color:#e6db74>.3</span><span style=color:#e6db74>}</span><span style=color:#e6db74>s&#39;</span>)
</span></span></code></pre></div><pre><code>1.23s
</code></pre><p>Why is this slow? Because <code>scipy</code> implementation of <code>fisher_exact</code> is writen in plain python. As this is the actual calculation part of our code, there should be room for improvement by using a faster implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_fate_bias_f</span>(clA,clB,clAsum, clBsum):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Perform Fisher extact test on clone counts</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>from</span> fast_fisher <span style=color:#f92672>import</span> fast_fisher_exact 
</span></span><span style=display:flex><span>    pvals <span style=color:#f92672>=</span> [fast_fisher_exact(cla,clb, clAsum, clBsum) 
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>for</span> cla,clb <span style=color:#f92672>in</span> zip(clA,clB)]
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get fate biasing using clone counts</span>
</span></span><span style=display:flex><span>    slope <span style=color:#f92672>=</span> clAsum<span style=color:#f92672>/</span>clBsum
</span></span><span style=display:flex><span>    fate_bias <span style=color:#f92672>=</span> clA<span style=color:#f92672>/</span> (clA <span style=color:#f92672>+</span> clB<span style=color:#f92672>/</span>slope)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pvals, slope, fate_bias
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>start <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>pvals, slope, fate_bias <span style=color:#f92672>=</span> get_fate_bias_f(clA,clB,clAsum, clBsum)
</span></span><span style=display:flex><span>end <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>(end<span style=color:#f92672>-</span>start)<span style=color:#e6db74>:</span><span style=color:#e6db74>.3</span><span style=color:#e6db74>}</span><span style=color:#e6db74>s&#39;</span>)
</span></span></code></pre></div><pre><code>0.00528s
</code></pre><p>Why is this fast? With simple google search, I found the python package <a href=https://github.com/MrTomRod/fast-fisher>fast_fisher</a>, which provides numba and cython implementations of the Fisher exact test. Numba compiles a function using LLVM compiler library, while Cython convert Python functions to compiled C code, both lead to great speedups.</p><h2 id=saving-the-data>Saving the data</h2><p>One might think that saving data is a trivial task. Here is how to avoid inefficiencies!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>assign_results</span>(adata,cid,pvals,fate_bias,cutoff):
</span></span><span style=display:flex><span>    adata<span style=color:#f92672>.</span>obs[<span style=color:#e6db74>&#34;fisher_pval&#34;</span>] <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>nan
</span></span><span style=display:flex><span>    adata<span style=color:#f92672>.</span>obs[<span style=color:#e6db74>&#34;fate_bias&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ci,p,f <span style=color:#f92672>in</span> zip(cid,pvals,fate_bias):
</span></span><span style=display:flex><span>        adata<span style=color:#f92672>.</span>obs<span style=color:#f92672>.</span>loc[adata<span style=color:#f92672>.</span>obs_names[ci],<span style=color:#e6db74>&#39;fisher_pval&#39;</span>]<span style=color:#f92672>=</span>p
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> p <span style=color:#f92672>&lt;</span> cutoff:
</span></span><span style=display:flex><span>            adata<span style=color:#f92672>.</span>obs<span style=color:#f92672>.</span>loc[adata<span style=color:#f92672>.</span>obs_names[ci],<span style=color:#e6db74>&#39;fate_bias&#39;</span>]<span style=color:#f92672>=</span>f
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>start <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>assign_results(adata,cid,pvals,fate_bias,cutoff)
</span></span><span style=display:flex><span>end <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>(end<span style=color:#f92672>-</span>start)<span style=color:#e6db74>:</span><span style=color:#e6db74>.3</span><span style=color:#e6db74>}</span><span style=color:#e6db74>s&#39;</span>)
</span></span></code></pre></div><pre><code>0.395s
</code></pre><p>Why is this slow? The function locates the index of the dataframe using <code>adata.obs_names[ci]</code> and assigns the values. This operation is not very efficient as it involves looking up the index for each individual element. In addition, <code>loc</code> is slow as the cell id needs to be converted into integer indexes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>assign_results_f</span>(adata,cid,pvals,fate_bias,cutoff):
</span></span><span style=display:flex><span>    adata<span style=color:#f92672>.</span>obs[<span style=color:#e6db74>&#34;fisher_pval&#34;</span>] <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>nan
</span></span><span style=display:flex><span>    adata<span style=color:#f92672>.</span>obs[<span style=color:#e6db74>&#34;fate_bias&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span>
</span></span><span style=display:flex><span>    c <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>concatenate(cid)
</span></span><span style=display:flex><span>    <span style=color:#75715e># prepare assignment array</span>
</span></span><span style=display:flex><span>    cid_len <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([len(c) <span style=color:#66d9ef>for</span> c <span style=color:#f92672>in</span> cid])
</span></span><span style=display:flex><span>    cid_pval_f <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>column_stack((
</span></span><span style=display:flex><span>        c, np<span style=color:#f92672>.</span>repeat(pvals, cid_len), 
</span></span><span style=display:flex><span>        np<span style=color:#f92672>.</span>repeat(fate_bias, cid_len)
</span></span><span style=display:flex><span>    ))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># assign values to anndata</span>
</span></span><span style=display:flex><span>    col <span style=color:#f92672>=</span> adata<span style=color:#f92672>.</span>obs<span style=color:#f92672>.</span>columns
</span></span><span style=display:flex><span>    adata<span style=color:#f92672>.</span>obs<span style=color:#f92672>.</span>iloc[cid_pval_f[:,<span style=color:#ae81ff>0</span>],col<span style=color:#f92672>==</span><span style=color:#e6db74>&#34;fisher_pval&#34;</span>] <span style=color:#f92672>=</span> cid_pval_f[:,<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    cid_pval_f <span style=color:#f92672>=</span> cid_pval_f[cid_pval_f[:,<span style=color:#ae81ff>1</span>]<span style=color:#f92672>&lt;</span>cutoff,:]
</span></span><span style=display:flex><span>    adata<span style=color:#f92672>.</span>obs<span style=color:#f92672>.</span>iloc[cid_pval_f[:,<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>astype(int),col<span style=color:#f92672>==</span><span style=color:#e6db74>&#34;fate_bias&#34;</span>] <span style=color:#f92672>=</span> cid_pval_f[:,<span style=color:#ae81ff>2</span>]  
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>start <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>assign_results_f(adata,cid,pvals,fate_bias,cutoff)
</span></span><span style=display:flex><span>end <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>(end<span style=color:#f92672>-</span>start)<span style=color:#e6db74>:</span><span style=color:#e6db74>.3</span><span style=color:#e6db74>}</span><span style=color:#e6db74>s&#39;</span>)
</span></span></code></pre></div><pre><code>0.00408s
</code></pre><p>Why is this fast? We prepare the assignment array outside the loop, which reduces the computational overhead. This assignment arrayis created by vectorized functions <code>np.repeat</code> and <code>np.column_stack</code>. To perform the actual assignment, we use <code>iloc</code> for indexing, which is faster than <code>loc</code> because it accesses the data directly by integer index. Lastly, we use boolean indexing (<code>cid_pval_f[:,1]&lt;cutoff</code>) to filter the data, which is more efficient than using a loop.</p><h2 id=overall-speed-comparison>Overall speed comparison</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>slow_implementation</span>(
</span></span><span style=display:flex><span>    adata,
</span></span><span style=display:flex><span>    clone <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;X_clone&#39;</span>,
</span></span><span style=display:flex><span>    fA <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Neutrophil&#39;</span>,
</span></span><span style=display:flex><span>    fB <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Monocyte&#39;</span>,
</span></span><span style=display:flex><span>    state_key <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;state_info&#39;</span>,
</span></span><span style=display:flex><span>    cutoff <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.01</span>):
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    cid <span style=color:#f92672>=</span> get_cellid_per_clone(adata,clone)
</span></span><span style=display:flex><span>    clA, clB, clAsum, clBsum <span style=color:#f92672>=</span> get_counts_per_clone(adata,cid,state_key)
</span></span><span style=display:flex><span>    pvals, slope, fate_bias <span style=color:#f92672>=</span> get_fate_bias(clA,clB,clAsum, clBsum)
</span></span><span style=display:flex><span>    assign_results(adata,cid,pvals,fate_bias,cutoff)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fast_implementation</span>(
</span></span><span style=display:flex><span>    adata,
</span></span><span style=display:flex><span>    clone <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;X_clone&#39;</span>,
</span></span><span style=display:flex><span>    fA <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Neutrophil&#39;</span>,
</span></span><span style=display:flex><span>    fB <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Monocyte&#39;</span>,
</span></span><span style=display:flex><span>    state_key <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;state_info&#39;</span>,
</span></span><span style=display:flex><span>    cutoff <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.01</span>):
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    cid <span style=color:#f92672>=</span> get_cellid_per_clone_f(adata,clone)
</span></span><span style=display:flex><span>    clA, clB, clAsum, clBsum <span style=color:#f92672>=</span> get_counts_per_clone_f(adata,cid,state_key)
</span></span><span style=display:flex><span>    pvals, slope, fate_bias <span style=color:#f92672>=</span> get_fate_bias_f(clA,clB,clAsum, clBsum)
</span></span><span style=display:flex><span>    assign_results_f(adata,cid,pvals,fate_bias,cutoff)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>start <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>slow_implementation(adata)
</span></span><span style=display:flex><span>end <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>slow_t <span style=color:#f92672>=</span> (end<span style=color:#f92672>-</span>start)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fate_bias_slow <span style=color:#f92672>=</span> adata<span style=color:#f92672>.</span>obs<span style=color:#f92672>.</span>fate_bias<span style=color:#f92672>.</span>copy()
</span></span><span style=display:flex><span>pvals_slow <span style=color:#f92672>=</span> adata<span style=color:#f92672>.</span>obs<span style=color:#f92672>.</span>fisher_pval<span style=color:#f92672>.</span>copy()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>start <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>fast_implementation(adata)
</span></span><span style=display:flex><span>end <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>fast_t<span style=color:#f92672>=</span>(end<span style=color:#f92672>-</span>start)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fate_bias_fast <span style=color:#f92672>=</span> adata<span style=color:#f92672>.</span>obs<span style=color:#f92672>.</span>fate_bias<span style=color:#f92672>.</span>copy()
</span></span><span style=display:flex><span>pvals_fast <span style=color:#f92672>=</span> adata<span style=color:#f92672>.</span>obs<span style=color:#f92672>.</span>fisher_pval<span style=color:#f92672>.</span>copy()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>(slow_t<span style=color:#f92672>/</span>fast_t)<span style=color:#e6db74>:</span><span style=color:#e6db74>.4</span><span style=color:#e6db74>}</span><span style=color:#e6db74>X speed improvement!&#39;</span>)
</span></span></code></pre></div><pre><code>259.3X speed improvement!
</code></pre><p>We achieved more than a 200X speed improvement! That is quite an accomplishment. It&rsquo;s important to note that the slower code benefited from the fast SSD of my MacBook. I would anticipate it running much slower on a system/HPC with slower storage.</p><h3 id=checking-consistency-between-two-approaches>Checking consistency between two approaches</h3><p>It is always important to check that you end up in the same result between the two implementation!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>np<span style=color:#f92672>.</span>array_equal(fate_bias_slow,fate_bias_fast)
</span></span></code></pre></div><pre><code>True
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Using allclose because of slight numerical differences </span>
</span></span><span style=display:flex><span><span style=color:#75715e># between python and C implementations</span>
</span></span><span style=display:flex><span>np<span style=color:#f92672>.</span>allclose(pvals_fast,pvals_slow) 
</span></span></code></pre></div><pre><code>True
</code></pre><h2 id=displaying-results>Displaying results</h2><p>Let&rsquo;s display our extracted fate biases</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>sc<span style=color:#f92672>.</span>pl<span style=color:#f92672>.</span>embedding(adata[(adata<span style=color:#f92672>.</span>obs<span style=color:#f92672>.</span>fate_bias<span style=color:#f92672>-</span><span style=color:#ae81ff>.5</span>)<span style=color:#f92672>.</span>abs()<span style=color:#f92672>.</span>sort_values()<span style=color:#f92672>.</span>index],
</span></span><span style=display:flex><span>                color<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;fate_bias&#34;</span>,basis<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;emb&#34;</span>,sort_order<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>,cmap<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;bwr&#39;</span>)
</span></span></code></pre></div><p><img alt=png src=/post/efficient_code_python/output_51_0.png></p><h2 id=take-home-messages-for-efficient-code-writing-and-sharing>Take home messages for efficient code writing and sharing</h2><ul><li>Before attempting to parallelize every possible for loop, try to vectorize your code as much as possible. Numpy provides a wide range of fast functions for this purpose.</li><li>Be mindful of data read/write and indexing, especially on slower HDD systems. Sometimes, pre-allocating data arrays and/or sorting indexes can be beneficial strategies.</li><li>For actual computations occuring on large datasets, use Numba or Cython implementations whenever possible. Writing in Numba is particularly straightforward as its syntax is identical to Python&rsquo;s.</li><li>Don&rsquo;t hesitate to explore the web or ask some LLMs. There&rsquo;s a good chance someone has already implemented a particular subfunction you need!</li><li>Identify the slow parts of your code by profiling the runtime line by line. A simple and effective tool for this task is <a href=https://github.com/pyutils/line_profiler>line_profiler</a>.</li></ul><p>However, there&rsquo;s an important caveat:</p><ul><li>Don&rsquo;t waste your time optimizing a code/function that isn&rsquo;t expected to be used frequently by you or other people. It&rsquo;s crucial to assess where our time is best invested!</li></ul></div><div class=share-box aria-hidden=true><ul class=share><li><a href="https://twitter.com/intent/tweet?url=https://louis.faure.dev/post/efficient_code_python/&amp;text=Scalable%20&amp;amp;%20Sustainable%20Computational%20Biology:%20Vectorization,%20Indexing%20Tricks,%20and%20Numba/Cython" target=_blank rel=noopener class=share-btn-twitter><i class="fab fa-twitter"></i></a></li><li><a href="https://www.facebook.com/sharer.php?u=https://louis.faure.dev/post/efficient_code_python/&amp;t=Scalable%20&amp;amp;%20Sustainable%20Computational%20Biology:%20Vectorization,%20Indexing%20Tricks,%20and%20Numba/Cython" target=_blank rel=noopener class=share-btn-facebook><i class="fab fa-facebook"></i></a></li><li><a href="mailto:?subject=Scalable%20&amp;amp;%20Sustainable%20Computational%20Biology:%20Vectorization,%20Indexing%20Tricks,%20and%20Numba/Cython&amp;body=https://louis.faure.dev/post/efficient_code_python/" target=_blank rel=noopener class=share-btn-email><i class="fas fa-envelope"></i></a></li><li><a href="https://www.linkedin.com/shareArticle?url=https://louis.faure.dev/post/efficient_code_python/&amp;title=Scalable%20&amp;amp;%20Sustainable%20Computational%20Biology:%20Vectorization,%20Indexing%20Tricks,%20and%20Numba/Cython" target=_blank rel=noopener class=share-btn-linkedin><i class="fab fa-linkedin-in"></i></a></li><li><a href="https://web.whatsapp.com/send?text=Scalable%20&amp;amp;%20Sustainable%20Computational%20Biology:%20Vectorization,%20Indexing%20Tricks,%20and%20Numba/Cython%20https://louis.faure.dev/post/efficient_code_python/" target=_blank rel=noopener class=share-btn-whatsapp><i class="fab fa-whatsapp"></i></a></li><li><a href="https://service.weibo.com/share/share.php?url=https://louis.faure.dev/post/efficient_code_python/&amp;title=Scalable%20&amp;amp;%20Sustainable%20Computational%20Biology:%20Vectorization,%20Indexing%20Tricks,%20and%20Numba/Cython" target=_blank rel=noopener class=share-btn-weibo><i class="fab fa-weibo"></i></a></li></ul></div><div class="media author-card content-widget-hr"><img class="portrait mr-3" src=/authors/authors/avatar_hu8cb5cec5c4abae32b2a3dbc9f09ba7f8_323173_250x250_fill_q90_lanczos_center.jpg alt=Avatar><div class=media-body><h5 class=card-title><a href=https://louis.faure.dev/>Louis Faure</a></h5><h6 class=card-subtitle>Postdoctoral Research Scholar</h6><ul class=network-icon aria-hidden=true><li><a href=mailto:faurel1@mskcc.org><i class="fas fa-envelope"></i></a></li><li><a href=https://mobile.twitter.com/LouisFaure_ target=_blank rel=noopener><i class="fab fa-twitter"></i></a></li><li><a href=https://orcid.org/0000-0003-4621-586X target=_blank rel=noopener><i class="fab fa-orcid"></i></a></li><li><a href=https://www.researchgate.net/profile/Louis-Faure target=_blank rel=noopener><i class="fab fa-researchgate"></i></a></li><li><a href="https://scholar.google.com/citations?user=Tc8i56oAAAAJ" target=_blank rel=noopener><i class="ai ai-google-scholar"></i></a></li><li><a href=https://github.com/louisfaure target=_blank rel=noopener><i class="fab fa-github"></i></a></li><li><a href=https://soundcloud.com/louisfaure target=_blank rel=noopener><i class="fab fa-soundcloud"></i></a></li></ul></div></div></div></article></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js integrity="sha256-1zu+3BnLYV9LdiY85uXMzii3bdrkelyp37e0ZyTAQh0=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/r.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.js integrity="sha256-EErZamuLefUnbMBQbsEqu1USa+btR2oIlCpBJbyD4/g=" crossorigin=anonymous></script><script>hljs.initHighlightingOnLoad()</script><script>const search_config={indexURI:"/index.json",minLength:1,threshold:.3},i18n={no_results:"No results found",placeholder:"Search...",results:"results found"},content_type={post:"Posts",project:"Projects",publication:"Publications",talk:"Talks"}</script><script id=search-hit-fuse-template type=text/x-template>
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script><script src=https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin=anonymous></script><script src=/js/academic.min.9e2a65f285b035fd303c931f04ab7bf5.js></script><div class=container><footer class=site-footer><p class=powered-by>Heavily customized
<a href=https://sourcethemes.com/academic/ target=_blank rel=noopener>Academic theme</a> for
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a>.
<span class=float-right aria-hidden=true><a href=# class=back-to-top><span class=button_icon><i class="fas fa-chevron-up fa-2x"></i></span></a></span></p></footer></div><div id=modal class="modal fade" role=dialog><div class=modal-dialog><div class=modal-content><div class=modal-header><h5 class=modal-title>Cite</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class=modal-body><pre><code class="tex hljs"></code></pre></div><div class=modal-footer><a class="btn btn-outline-primary my-1 js-copy-cite" href=# target=_blank><i class="fas fa-copy"></i> Copy
</a><a class="btn btn-outline-primary my-1 js-download-cite" href=# target=_blank><i class="fas fa-download"></i> Download</a><div id=modal-error></div></div></div></div></div></body></html>