<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts | Louis Faure</title><link>https://louis.faure.dev/post/</link><atom:link href="https://louis.faure.dev/post/index.xml" rel="self" type="application/rss+xml"/><description>Posts</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Fri, 29 Mar 2024 00:00:00 +0000</lastBuildDate><image><url>https://louis.faure.dev/img/icon-192.png</url><title>Posts</title><link>https://louis.faure.dev/post/</link></image><item><title>Scalable &amp; Sustainable Computational Biology: Vectorization, Indexing Tricks, and Numba/Cython</title><link>https://louis.faure.dev/post/efficient_code_python/</link><pubDate>Fri, 29 Mar 2024 00:00:00 +0000</pubDate><guid>https://louis.faure.dev/post/efficient_code_python/</guid><description>&lt;p>&lt;a href="https://github.com/LouisFaure/Blog_notebooks/blob/main/efficient_code_python
/Efficient_code_python.ipynb">&lt;img alt="Jupyter Notebook" src="https://img.shields.io/badge/jupyter-%23FA0F00.svg?style=for-the-badge&amp;amp;logo=jupyter&amp;amp;logoColor=white" style="margin-left:0;margin-top:0;margin-bottom:0;border-radius:5px; box-shadow:0 4px 16px 0 rgba(0, 0, 0, 0.1);">&lt;/a>&lt;/p>
&lt;p>Speeding up code is sometimes an overlooked aspect in the field of computational biology. Numerous constraints (multiple projects, thesis writing, pressure to publish, etc.) often lead many to write simple implementations of a given function, at the expense of efficiency. This is problematic as such code is not scalable, which can limit further discoveries done by other researchers. In this article, I will look at all tasks performed by a specific Python function I have designed, showing first an example of slow code, and then a suggestion of a faster implementation. I hope this will provide some tips to you to perform a scalable, more efficient, and &lt;a href="https://www.green-algorithms.org">environmentally friendly&lt;/a> science!&lt;/p>
&lt;h2 id="the-task">The Task&lt;/h2>
&lt;p>During my research, I was assigned to implement a relatively simple function. We work with single-cell data that includes clonal barcodes. These barcodes allow us to group and identify cells that belong to the same lineage, as a barcode would be passed from the mother cell to all subsequent daughter cells. Clonal barcoding is a potent tool for studying early fate biasing and can be used as input for some tools to infer the fate of non-barcoded neighboring cells.&lt;/p>
&lt;p>The most basic fate bias estimation between two fates in barcoded cells consists of counting the occurrences of the fates in each clone. We then compare these occurrences to the ones of other fates to statistically assign a fate bias.&lt;/p>
&lt;p>More precisely, we will calculate the fate bias $f$ as follows:
&lt;/p>
$$
f = \frac{c_A}{c_A+{c_B}\times{\alpha}^{-1}}
$$
&lt;p>with $c_A$ and $c_B$ being the number of occurrences of our fates A and B in each clone, and $\alpha= \frac{\sum c_A}{\sum c_B}$ is the ratio of the sum of all observed clones for each fate.&lt;/p>
&lt;p>To test of significance of fate bias, we will perform a Fisher exact test, with a 2x2 contingency table:&lt;/p>
$$
\begin{align*}
\begin{array}{|c|c|}
\hline
c_A &amp; c_B \\
\hline
\sum c_A &amp; \sum c_B \\
\hline
\end{array}
\end{align*}
$$
&lt;p>While this task should not be compute-intensive, there are several good examples of slow and inefficient code that can be fixed. You will see that slowness is not only caused by slow calculation but also by data access!&lt;/p>
&lt;h3 id="the-system-used-for-benchmark">The system used for benchmark&lt;/h3>
&lt;p>The numbers showed here come from tests with my MacBook Pro M2P 32GB.&lt;/p>
&lt;p>I used python 3.10.13 and installed the following packages:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pip install cospar fast_fisher
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="loading-libraries-and-the-data">Loading libraries and the data&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> cospar &lt;span style="color:#66d9ef">as&lt;/span> cs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> warnings
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> scanpy &lt;span style="color:#66d9ef">as&lt;/span> sc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> numpy &lt;span style="color:#66d9ef">as&lt;/span> np
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> pandas &lt;span style="color:#66d9ef">as&lt;/span> pd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> time
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sc&lt;span style="color:#f92672">.&lt;/span>set_figure_params()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>warnings&lt;span style="color:#f92672">.&lt;/span>filterwarnings(&lt;span style="color:#e6db74">&amp;#39;ignore&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="quick-overview-of-the-data">Quick overview of the data&lt;/h3>
&lt;p>The data we will use here is a 30k+ cells &lt;a href="https://www.science.org/doi/10.1126/science.aaw3381">dataset of mouse hematopoiesis&lt;/a>. The cells were clonally barcoded once and then were subsequently sampled at multiple time points.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>adata_orig &lt;span style="color:#f92672">=&lt;/span> cs&lt;span style="color:#f92672">.&lt;/span>datasets&lt;span style="color:#f92672">.&lt;/span>hematopoiesis()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We will focus on the bifurcation between Monocytes and Neutrophils:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>mask &lt;span style="color:#f92672">=&lt;/span> adata_orig&lt;span style="color:#f92672">.&lt;/span>obs&lt;span style="color:#f92672">.&lt;/span>state_info&lt;span style="color:#f92672">.&lt;/span>isin([&lt;span style="color:#e6db74">&amp;#34;Monocyte&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;Neutrophil&amp;#34;&lt;/span>]) &lt;span style="color:#f92672">|&lt;/span> adata_orig&lt;span style="color:#f92672">.&lt;/span>obs&lt;span style="color:#f92672">.&lt;/span>NeuMon_mask
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>adata &lt;span style="color:#f92672">=&lt;/span> adata_orig[mask]&lt;span style="color:#f92672">.&lt;/span>copy()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>sc&lt;span style="color:#f92672">.&lt;/span>pl&lt;span style="color:#f92672">.&lt;/span>embedding(adata,color&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;state_info&amp;#34;&lt;/span>,basis&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;emb&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img alt="png" src="https://louis.faure.dev/post/efficient_code_python/output_10_0.png">&lt;/p>
&lt;h3 id="some-parameters-needed">Some parameters needed&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>clone &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;X_clone&amp;#39;&lt;/span> &lt;span style="color:#75715e"># key to access the clonal matrix&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fA &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Neutrophil&amp;#39;&lt;/span> &lt;span style="color:#75715e"># fate A&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fB &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Monocyte&amp;#39;&lt;/span> &lt;span style="color:#75715e"># fate B&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>state_key &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;state_info&amp;#39;&lt;/span> &lt;span style="color:#75715e"># key for fate assignments&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cutoff &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.01&lt;/span> &lt;span style="color:#75715e"># cutoff for Fisher test corrected p-values&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="getting-cell-indices-for-each-clone">Getting cell indices for each clone&lt;/h2>
&lt;p>We use a clone matrix saved in anndata under &lt;code>obsm&lt;/code> as a sparse matrix, where the rows are cells and columns are clones. We need to extract which cell belongs to which clone. In other words, the task is to retrieve the row indices of each column.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_cellid_per_clone&lt;/span>(adata,clone):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X_clone &lt;span style="color:#f92672">=&lt;/span> adata&lt;span style="color:#f92672">.&lt;/span>obsm[clone]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [np&lt;span style="color:#f92672">.&lt;/span>argwhere(X_clone[:,i])[:,&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(X_clone&lt;span style="color:#f92672">.&lt;/span>shape[&lt;span style="color:#ae81ff">1&lt;/span>])]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>start &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cid &lt;span style="color:#f92672">=&lt;/span> get_cellid_per_clone(adata,clone)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>(end&lt;span style="color:#f92672">-&lt;/span>start)&lt;span style="color:#e6db74">:&lt;/span>&lt;span style="color:#e6db74">.3&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">s&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>0.756s
&lt;/code>&lt;/pre>
&lt;p>Why is this method slow? Though this approach is straightforward (practically one line), a &lt;code>for&lt;/code> loop that calls &lt;code>np.argwhere&lt;/code> for each of the columns implies that we are not leveraging NumPy&amp;rsquo;s ability to perform operations on entire arrays at once.&lt;/p>
&lt;p>Let&amp;rsquo;s have a look at a faster implementation:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_cellid_per_clone_f&lt;/span>(adata,clone):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> X_clone &lt;span style="color:#f92672">=&lt;/span> adata&lt;span style="color:#f92672">.&lt;/span>obsm[clone]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Extract and sort row and columns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rows, cols &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>nonzero(X_clone)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sort_idx &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>argsort(cols)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rows_sorted &lt;span style="color:#f92672">=&lt;/span> rows[sort_idx]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cols_sorted &lt;span style="color:#f92672">=&lt;/span> cols[sort_idx]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Get the count of unique columns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _, counts &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>unique(cols_sorted, return_counts&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Split rows_sorted based on counts&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>split(rows_sorted, np&lt;span style="color:#f92672">.&lt;/span>cumsum(counts[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>start &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cid &lt;span style="color:#f92672">=&lt;/span> get_cellid_per_clone_f(adata,clone)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>(end&lt;span style="color:#f92672">-&lt;/span>start)&lt;span style="color:#e6db74">:&lt;/span>&lt;span style="color:#e6db74">.3&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">s&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>0.00539s
&lt;/code>&lt;/pre>
&lt;p>Why is this fast? Because we use NumPy&amp;rsquo;s vectorized function &lt;code>np.nonzero&lt;/code> to find the indices of non-zero elements in the entire array at once. Then, we sort these indices based on the column indices and split them into separate arrays for each column. By sorting the indices based on the column indices (&lt;code>np.argsort&lt;/code> is also vectorized), the function avoids having to access the columns individually.&lt;/p>
&lt;h2 id="getting-the-occurrence-of-our-two-fate-labels-in-each-clone">Getting the occurrence of our two fate labels in each clone&lt;/h2>
&lt;p>We want to count the occurrence of our two fate labels in each clone and the total of each fate. This involves retrieving the cluster assignment for each cell within each clone.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_counts_per_clone&lt;/span>(adata,cid,state_key):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Convert cell id to assigned cell state for each clone&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cl &lt;span style="color:#f92672">=&lt;/span> [adata[c]&lt;span style="color:#f92672">.&lt;/span>obs[state_key] &lt;span style="color:#66d9ef">for&lt;/span> c &lt;span style="color:#f92672">in&lt;/span> cid]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Count occurences of states per clone&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clA &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>array([(c&lt;span style="color:#f92672">==&lt;/span>fA)&lt;span style="color:#f92672">.&lt;/span>sum() &lt;span style="color:#66d9ef">for&lt;/span> c &lt;span style="color:#f92672">in&lt;/span> cl])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clB &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>array([(c&lt;span style="color:#f92672">==&lt;/span>fB)&lt;span style="color:#f92672">.&lt;/span>sum() &lt;span style="color:#66d9ef">for&lt;/span> c &lt;span style="color:#f92672">in&lt;/span> cl])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clAsum, clBsum &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>sum(clA) , np&lt;span style="color:#f92672">.&lt;/span>sum(clB)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> clA, clB, clAsum, clBsum
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>start &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>clA, clB, clAsum, clBsum &lt;span style="color:#f92672">=&lt;/span> get_counts_per_clone(adata,cid,state_key)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>(end&lt;span style="color:#f92672">-&lt;/span>start)&lt;span style="color:#e6db74">:&lt;/span>&lt;span style="color:#e6db74">.3&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">s&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>1.71s
&lt;/code>&lt;/pre>
&lt;p>Why is this slow? Here the issue lies in the repeated access of the anndata object in a &lt;code>for&lt;/code> loop, which is quite inefficient. Also, although this does not have that much of an impact, the function calculates the sum of clA and clB separately.&lt;/p>
&lt;p>Here is a faster implementation:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_counts_per_clone_f&lt;/span>(adata,cid,state_key):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Get cell id and clone id array&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>repeat(np&lt;span style="color:#f92672">.&lt;/span>arange(len(cid)), [len(c) &lt;span style="color:#66d9ef">for&lt;/span> c &lt;span style="color:#f92672">in&lt;/span> cid])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>concatenate(cid)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cid_cl &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>column_stack((c, i))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># apply cell/clone id array to states array&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df &lt;span style="color:#f92672">=&lt;/span> adata&lt;span style="color:#f92672">.&lt;/span>obs[[state_key]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df[&lt;span style="color:#e6db74">&amp;#34;clone&amp;#34;&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>np&lt;span style="color:#f92672">.&lt;/span>nan
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df&lt;span style="color:#f92672">.&lt;/span>iloc[cid_cl[:,&lt;span style="color:#ae81ff">0&lt;/span>],&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>cid_cl[:,&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Count occurences of states per clone&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cnts &lt;span style="color:#f92672">=&lt;/span> df&lt;span style="color:#f92672">.&lt;/span>groupby(state_key)&lt;span style="color:#f92672">.&lt;/span>value_counts([&lt;span style="color:#e6db74">&amp;#34;clone&amp;#34;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clAB &lt;span style="color:#f92672">=&lt;/span> pd&lt;span style="color:#f92672">.&lt;/span>concat([cnts[fA]&lt;span style="color:#f92672">.&lt;/span>sort_index(),cnts[fB]&lt;span style="color:#f92672">.&lt;/span>sort_index()],axis&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>values
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clA, clB &lt;span style="color:#f92672">=&lt;/span> clAB[:,&lt;span style="color:#ae81ff">0&lt;/span>], clAB[:,&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clAsum, clBsum &lt;span style="color:#f92672">=&lt;/span> clAB&lt;span style="color:#f92672">.&lt;/span>sum(axis&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> clA, clB, clAsum, clBsum
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>start &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>clA, clB, clAsum, clBsum &lt;span style="color:#f92672">=&lt;/span> get_counts_per_clone_f(adata,cid,state_key)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>(end&lt;span style="color:#f92672">-&lt;/span>start)&lt;span style="color:#e6db74">:&lt;/span>&lt;span style="color:#e6db74">.3&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">s&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>0.0103s
&lt;/code>&lt;/pre>
&lt;p>Why is this fast? First, we used vectorized functions &lt;code>np.column_stack&lt;/code> and &lt;code>np.repeat&lt;/code> to create a NumPy array assigning each cell index to a clone id. Then, we use the &lt;code>groupby&lt;/code> method from pandas, which is optimized for grouping and aggregating data. Finally, the anndata is read and written only once, avoiding the usage of any &lt;code>for&lt;/code> loop.&lt;/p>
&lt;h2 id="calculating-fate-bias-and-its-significance-per-cell">Calculating fate bias and its significance per cell&lt;/h2>
&lt;p>We will use the equation mentioned in the introduction, as well as the Fisher exact test. More precisely, we will perform the test on each clone using extracted counts of our two fates and their total sum.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_fate_bias&lt;/span>(clA,clB,clAsum, clBsum):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Perform Fisher extact test on clone counts&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">from&lt;/span> scipy.stats &lt;span style="color:#f92672">import&lt;/span> fisher_exact
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pvals &lt;span style="color:#f92672">=&lt;/span> [fisher_exact(np&lt;span style="color:#f92672">.&lt;/span>array([[cla,clb], [clAsum, clBsum]]))[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> cla,clb &lt;span style="color:#f92672">in&lt;/span> zip(clA,clB)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Get fate biasing using clone counts&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slope &lt;span style="color:#f92672">=&lt;/span> clAsum&lt;span style="color:#f92672">/&lt;/span>clBsum
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fate_bias &lt;span style="color:#f92672">=&lt;/span> clA&lt;span style="color:#f92672">/&lt;/span> (clA &lt;span style="color:#f92672">+&lt;/span> clB&lt;span style="color:#f92672">/&lt;/span>slope)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> pvals, slope, fate_bias
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>start &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pvals, slope, fate_bias &lt;span style="color:#f92672">=&lt;/span> get_fate_bias(clA,clB,clAsum, clBsum)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>(end&lt;span style="color:#f92672">-&lt;/span>start)&lt;span style="color:#e6db74">:&lt;/span>&lt;span style="color:#e6db74">.3&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">s&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>1.17s
&lt;/code>&lt;/pre>
&lt;p>Why is this slow? Because &lt;code>scipy&lt;/code> implementation of &lt;code>fisher_exact&lt;/code> is written in plain Python. As this is the actual calculation part of our code, there should be room for improvement by using a faster implementation:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_fate_bias_f&lt;/span>(clA,clB,clAsum, clBsum):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Perform Fisher extact test on clone counts&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">from&lt;/span> fast_fisher &lt;span style="color:#f92672">import&lt;/span> fast_fisher_exact
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pvals &lt;span style="color:#f92672">=&lt;/span> [fast_fisher_exact(cla,clb, clAsum, clBsum)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> cla,clb &lt;span style="color:#f92672">in&lt;/span> zip(clA,clB)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Get fate biasing using clone counts&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slope &lt;span style="color:#f92672">=&lt;/span> clAsum&lt;span style="color:#f92672">/&lt;/span>clBsum
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fate_bias &lt;span style="color:#f92672">=&lt;/span> clA&lt;span style="color:#f92672">/&lt;/span> (clA &lt;span style="color:#f92672">+&lt;/span> clB&lt;span style="color:#f92672">/&lt;/span>slope)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> pvals, slope, fate_bias
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>start &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pvals, slope, fate_bias &lt;span style="color:#f92672">=&lt;/span> get_fate_bias_f(clA,clB,clAsum, clBsum)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>(end&lt;span style="color:#f92672">-&lt;/span>start)&lt;span style="color:#e6db74">:&lt;/span>&lt;span style="color:#e6db74">.3&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">s&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>0.0154s
&lt;/code>&lt;/pre>
&lt;p>Why is this fast? With a simple Google search, I found the Python package &lt;a href="https://github.com/MrTomRod/fast-fisher">fast_fisher&lt;/a>, which provides Numba and Python implementations of the Fisher exact test. Numba compiles a function using the LLVM compiler library, while Cython converts Python functions to compiled C code, both lead to great speedups.&lt;/p>
&lt;h2 id="saving-the-data">Saving the data&lt;/h2>
&lt;p>One might think that saving data is a trivial task. Here is how to avoid inefficiencies!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">assign_results&lt;/span>(adata,cid,pvals,fate_bias,cutoff):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adata&lt;span style="color:#f92672">.&lt;/span>obs[&lt;span style="color:#e6db74">&amp;#34;fisher_pval&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>nan
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adata&lt;span style="color:#f92672">.&lt;/span>obs[&lt;span style="color:#e6db74">&amp;#34;fate_bias&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> ci,p,f &lt;span style="color:#f92672">in&lt;/span> zip(cid,pvals,fate_bias):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adata&lt;span style="color:#f92672">.&lt;/span>obs&lt;span style="color:#f92672">.&lt;/span>loc[adata&lt;span style="color:#f92672">.&lt;/span>obs_names[ci],&lt;span style="color:#e6db74">&amp;#39;fisher_pval&amp;#39;&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>p
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> p &lt;span style="color:#f92672">&amp;lt;&lt;/span> cutoff:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adata&lt;span style="color:#f92672">.&lt;/span>obs&lt;span style="color:#f92672">.&lt;/span>loc[adata&lt;span style="color:#f92672">.&lt;/span>obs_names[ci],&lt;span style="color:#e6db74">&amp;#39;fate_bias&amp;#39;&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>f
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>start &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>assign_results(adata,cid,pvals,fate_bias,cutoff)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>(end&lt;span style="color:#f92672">-&lt;/span>start)&lt;span style="color:#e6db74">:&lt;/span>&lt;span style="color:#e6db74">.3&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">s&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>0.38s
&lt;/code>&lt;/pre>
&lt;p>Why is this slow? The function locates the index of the dataframe using &lt;code>adata.obs_names[ci]&lt;/code> and assigns the values. This operation is not very efficient as it involves looking up the index for each element. In addition, &lt;code>loc&lt;/code> is slow as the cell id needs to be converted into integer indexes.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">assign_results_f&lt;/span>(adata,cid,pvals,fate_bias,cutoff):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adata&lt;span style="color:#f92672">.&lt;/span>obs[&lt;span style="color:#e6db74">&amp;#34;fisher_pval&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>nan
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adata&lt;span style="color:#f92672">.&lt;/span>obs[&lt;span style="color:#e6db74">&amp;#34;fate_bias&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>concatenate(cid)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># prepare assignment array&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cid_len &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>array([len(c) &lt;span style="color:#66d9ef">for&lt;/span> c &lt;span style="color:#f92672">in&lt;/span> cid])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cid_pval_f &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>column_stack((
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c, np&lt;span style="color:#f92672">.&lt;/span>repeat(pvals, cid_len),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> np&lt;span style="color:#f92672">.&lt;/span>repeat(fate_bias, cid_len)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># assign values to anndata&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> col &lt;span style="color:#f92672">=&lt;/span> adata&lt;span style="color:#f92672">.&lt;/span>obs&lt;span style="color:#f92672">.&lt;/span>columns
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adata&lt;span style="color:#f92672">.&lt;/span>obs&lt;span style="color:#f92672">.&lt;/span>iloc[cid_pval_f[:,&lt;span style="color:#ae81ff">0&lt;/span>],col&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#34;fisher_pval&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> cid_pval_f[:,&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cid_pval_f &lt;span style="color:#f92672">=&lt;/span> cid_pval_f[cid_pval_f[:,&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">&amp;lt;&lt;/span>cutoff,:]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adata&lt;span style="color:#f92672">.&lt;/span>obs&lt;span style="color:#f92672">.&lt;/span>iloc[cid_pval_f[:,&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>astype(int),col&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#34;fate_bias&amp;#34;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> cid_pval_f[:,&lt;span style="color:#ae81ff">2&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>start &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>assign_results_f(adata,cid,pvals,fate_bias,cutoff)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>(end&lt;span style="color:#f92672">-&lt;/span>start)&lt;span style="color:#e6db74">:&lt;/span>&lt;span style="color:#e6db74">.3&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">s&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>0.00429s
&lt;/code>&lt;/pre>
&lt;p>Why is this fast? We prepare the assignment array outside the loop, which reduces the computational overhead. This assignment array is created by vectorized functions &lt;code>np.repeat&lt;/code> and &lt;code>np.column_stack&lt;/code>. To perform the actual assignment, we use &lt;code>iloc&lt;/code> for indexing, which is faster than &lt;code>loc&lt;/code> because it accesses the data directly by integer index. Lastly, we use boolean indexing (&lt;code>cid_pval_f[:,1]&amp;lt;cutoff&lt;/code>) to filter the data, which is more efficient than using a loop.&lt;/p>
&lt;h2 id="overall-speed-comparison">Overall speed comparison&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">slow_implementation&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adata,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clone &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;X_clone&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fA &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Neutrophil&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fB &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Monocyte&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state_key &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;state_info&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cutoff &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.01&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cid &lt;span style="color:#f92672">=&lt;/span> get_cellid_per_clone(adata,clone)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clA, clB, clAsum, clBsum &lt;span style="color:#f92672">=&lt;/span> get_counts_per_clone(adata,cid,state_key)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pvals, slope, fate_bias &lt;span style="color:#f92672">=&lt;/span> get_fate_bias(clA,clB,clAsum, clBsum)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assign_results(adata,cid,pvals,fate_bias,cutoff)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fast_implementation&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> adata,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clone &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;X_clone&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fA &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Neutrophil&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fB &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Monocyte&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state_key &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;state_info&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cutoff &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.01&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cid &lt;span style="color:#f92672">=&lt;/span> get_cellid_per_clone_f(adata,clone)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clA, clB, clAsum, clBsum &lt;span style="color:#f92672">=&lt;/span> get_counts_per_clone_f(adata,cid,state_key)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pvals, slope, fate_bias &lt;span style="color:#f92672">=&lt;/span> get_fate_bias_f(clA,clB,clAsum, clBsum)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assign_results_f(adata,cid,pvals,fate_bias,cutoff)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>start &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>slow_implementation(adata)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>slow_t &lt;span style="color:#f92672">=&lt;/span> (end&lt;span style="color:#f92672">-&lt;/span>start)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fate_bias_slow &lt;span style="color:#f92672">=&lt;/span> adata&lt;span style="color:#f92672">.&lt;/span>obs&lt;span style="color:#f92672">.&lt;/span>fate_bias&lt;span style="color:#f92672">.&lt;/span>copy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pvals_slow &lt;span style="color:#f92672">=&lt;/span> adata&lt;span style="color:#f92672">.&lt;/span>obs&lt;span style="color:#f92672">.&lt;/span>fisher_pval&lt;span style="color:#f92672">.&lt;/span>copy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>start &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fast_implementation(adata)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end &lt;span style="color:#f92672">=&lt;/span> time&lt;span style="color:#f92672">.&lt;/span>time()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fast_t&lt;span style="color:#f92672">=&lt;/span>(end&lt;span style="color:#f92672">-&lt;/span>start)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fate_bias_fast &lt;span style="color:#f92672">=&lt;/span> adata&lt;span style="color:#f92672">.&lt;/span>obs&lt;span style="color:#f92672">.&lt;/span>fate_bias&lt;span style="color:#f92672">.&lt;/span>copy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pvals_fast &lt;span style="color:#f92672">=&lt;/span> adata&lt;span style="color:#f92672">.&lt;/span>obs&lt;span style="color:#f92672">.&lt;/span>fisher_pval&lt;span style="color:#f92672">.&lt;/span>copy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>(slow_t&lt;span style="color:#f92672">/&lt;/span>fast_t)&lt;span style="color:#e6db74">:&lt;/span>&lt;span style="color:#e6db74">.4&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">X speed improvement!&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>243.6X speed improvement!
&lt;/code>&lt;/pre>
&lt;p>We achieved more than a 200X speed improvement! That is quite an accomplishment. It&amp;rsquo;s important to note that the slower code benefited from the fast SSD of my MacBook. I would anticipate it running much slower on a system/HPC with slower storage.&lt;/p>
&lt;h3 id="checking-consistency-between-two-approaches">Checking consistency between two approaches&lt;/h3>
&lt;p>It is always important to check that we end up with the same result between the two implementations!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>np&lt;span style="color:#f92672">.&lt;/span>array_equal(fate_bias_slow,fate_bias_fast)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>True
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Using allclose because of slight numerical differences &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># between python and C implementations&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>np&lt;span style="color:#f92672">.&lt;/span>allclose(pvals_fast,pvals_slow)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>True
&lt;/code>&lt;/pre>
&lt;h2 id="displaying-results">Displaying results&lt;/h2>
&lt;p>Let&amp;rsquo;s display our extracted fate biases&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>sc&lt;span style="color:#f92672">.&lt;/span>pl&lt;span style="color:#f92672">.&lt;/span>embedding(adata[(adata&lt;span style="color:#f92672">.&lt;/span>obs&lt;span style="color:#f92672">.&lt;/span>fate_bias&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">.5&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>abs()&lt;span style="color:#f92672">.&lt;/span>sort_values()&lt;span style="color:#f92672">.&lt;/span>index],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> color&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;fate_bias&amp;#34;&lt;/span>,basis&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;emb&amp;#34;&lt;/span>,sort_order&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">False&lt;/span>,cmap&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;bwr&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img alt="png" src="https://louis.faure.dev/post/efficient_code_python/output_51_0.png">&lt;/p>
&lt;h2 id="take-home-messages-for-efficient-code-writing-and-sharing">Take home messages for efficient code writing and sharing&lt;/h2>
&lt;ul>
&lt;li>Before attempting to parallelize every possible for loop, try to vectorize your code as much as possible. Numpy provides a wide range of fast functions for this purpose.&lt;/li>
&lt;li>Be mindful of data read/write and indexing, especially on slower HDD systems. Sometimes, pre-allocating data arrays and/or sorting indexes can be beneficial strategies.&lt;/li>
&lt;li>For actual computations occurring on large datasets, use Numba or Cython implementations whenever possible. Writing in Numba is particularly straightforward as its syntax is identical to Python&amp;rsquo;s.&lt;/li>
&lt;li>Don&amp;rsquo;t hesitate to explore the web or ask some LLMs. There&amp;rsquo;s a good chance someone has already implemented a particular subfunction you need!&lt;/li>
&lt;li>Identify the slow parts of your code by profiling the runtime line by line. A simple and effective tool for this task is &lt;a href="https://github.com/pyutils/line_profiler">line_profiler&lt;/a>.&lt;/li>
&lt;/ul>
&lt;p>However, there&amp;rsquo;s an important caveat:&lt;/p>
&lt;ul>
&lt;li>Don&amp;rsquo;t waste your time optimizing a code/function that isn&amp;rsquo;t expected to be used frequently by you or other people. It&amp;rsquo;s crucial to assess where our time is best invested!&lt;/li>
&lt;/ul></description></item></channel></rss>